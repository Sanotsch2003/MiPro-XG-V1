library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

--control signals explained:

--operand1&2Sel:
--00001 to 01111 : R0 to R15(PC)
--10000          : dataOut from CU
--others         : zero

--dataToRegistersSel:
--0              :  data from ALU is passed to register file 
--1              :  external data (from memory) is passed to register file

entity controlUnit is
    Generic(
        numInterrupts : integer := 10
    );

    Port(
        enable              : in std_logic;
        hardwareReset       : in std_logic;
        softwareReset       : out std_logic;
        clk                 : in std_logic;
        alteredClk          : in std_logic;

        --control signals generated by CU
        operand1Sel         : out std_logic_vector(4 downto 0);
        operand2Sel         : out std_logic_vector(4 downto 0); 
        dataToMemSel        : out std_logic_vector(3 downto 0);

        dataToRegistersSel  : out std_logic;
        loadRegistersSel    : out std_logic_vector(15 downto 0);

        bitManipulationCode : out std_logic_vector(1 downto 0);
        bitManipulationValue: out std_logic_vector(4 downto 0);

        ALU_opCode          : out std_logic_vector(3 downto 0);
        carryIn             : out std_logic;
        upperSel            : out std_logic;

        memWriteReq         : out std_logic;
        memReadReq          : out std_logic;

        clearInterrupts     : out std_logic_vector(numInterrupts-1 downto 0);

        dataOut             : out std_logic_vector(31 downto 0);
          
        --signals controlling the CU

        programmingMode     : in std_logic;
        IVT_address         : in std_logic_vector(31 downto 0);
        dataIn              : in std_logic_vector(31 downto 0);
        flagsCPSR           : in std_logic_vector(3 downto 0);
        memOpFinished       : in std_logic;

        --debug signals
        debug : out std_logic_vector(49 downto 0)
);
end controlUnit;

architecture Behavioral of controlUnit is
    type procStateType      is (FETCH1, DECODE_EXECUTE);
    type executeStateType   is (DECODE_EXECUTE1, DECODE_EXECUTE2 ,DECODE_EXECUTE3, DECODE_EXECUTE4, DECODE_EXECUTE5, DECODE_EXECUTE6);

    signal procState        : procStateType    := FETCH1;
    signal procState_nxt    : procStateType;

    signal executeState     : executeStateType := DECODE_EXECUTE1;
    signal executeState_nxt : executeStateType;

    --internal registers
    signal currentlyHandlingInterruptRegister : std_logic;

    signal instructionRegister                : std_logic_vector(31 downto 0);
    signal instructionRegister_nxt            : std_logic_vector(31 downto 0);

    signal CPSR_Register                      : std_logic_vector(3 downto 0);

    signal Z_flag : std_logic;
    signal N_flag : std_logic;
    signal V_flag : std_logic;
    signal C_flag : std_logic; 


begin
    Z_flag <= CPSR_Register(3);
    N_flag <= CPSR_Register(2);
    V_flag <= CPSR_Register(1);
    c_flag <= CPSR_Register(0);

    --setting signals
    process(procState, executeState, programmingMode, IVT_address, dataIn, flagsCPSR, memOpFinished)
    begin
        --default assignments
        operand1Sel             <= (others => '1');
        operand2Sel             <= (others => '1');
        dataToMemSel            <= (others => '0');
        dataToRegistersSel      <= '0';
        loadRegistersSel        <= (others => '0');
        bitManipulationCode     <= (others => '0');
        bitManipulationValue    <= (others => '0');
        ALU_opCode              <= (others => '0');
        carryIn                 <= '0';
        upperSel                <= '0';
        memWriteReq             <= '0';
        memReadReq              <= '0';
        clearInterrupts         <= (others => '0');
        dataOut                 <= (others => '0');

        instructionRegister_nxt <= instructionRegister;
        procState_nxt           <= procState;
        executeState_nxt        <= executeState;

        if procState = FETCH1 then
            operand2Sel         <= "01111";     --selecting PC as operand 2
            dataToRegistersSel  <= '0';         --sending data from ALU to registers
            operand1Sel         <= "10000";     --dataOut as operand 1
            dataOut             <= x"00000004"; --set dataOut to 4 to increment PC later
            ALU_opCode          <= "1011";      --tell ALU to move the data
            memReadReq          <= '1';
            if memOpFinished = '1' then                     --wait for data to arrive   
                instructionRegister_nxt <= dataIn;          --load current instruction into the instruction register
                ALU_opCode          <= "0111";              --tell ALU to add operand1 (4) to the PC
                loadRegistersSel    <= "1000000000000000";  --load value back into PC
                procState_nxt <= DECODE_EXECUTE;
            end if;

        elsif procState = DECODE_EXECUTE then
            procState_nxt <= FETCH1;
        else 
            null;
        end if;
    end process;


    --updating registers
    process(clk, hardwareReset)
    begin
        if hardwareReset = '1' then
            procState           <= FETCH1;
            executeState        <= DECODE_EXECUTE1;
            instructionRegister <= (others => '0');
            
        elsif rising_edge(clk) then
            if enable = '1' then
                if alteredClk = '1' then
                    procState           <= procState_nxt;
                    executeState        <= executeState_nxt;
                    instructionRegister <= instructionRegister_nxt;
                end if;
            end if;
        end if;

    end process;


end Behavioral;
