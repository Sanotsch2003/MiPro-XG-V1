library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

--control signals explained:

--operand1&2Sel:
--00001 to 01111 : R0 to R15(PC)
--10000          : dataToALU from CU
--others         : zero

--dataToRegistersSel:
--0              :  data from ALU is passed to register file 
--1              :  external data (from memory) is passed to register file

entity controlUnit is
    Generic(
        numInterrupts : integer := 10
    );

    Port(
        enable                  : in std_logic;
        hardwareReset           : in std_logic;
        softwareReset           : out std_logic;
        clk                     : in std_logic;
        alteredClk              : in std_logic;

        --control signals generated by CU
        operand1Sel             : out std_logic_vector(4 downto 0);
        operand2Sel             : out std_logic_vector(4 downto 0); 
        dataToMemSel            : out std_logic_vector(3 downto 0);

        dataToRegistersSel      : out std_logic;
        loadRegistersSel        : out std_logic_vector(15 downto 0);
        bitManipulationValSel   : out std_logic_vector(4 downto 0);

        bitManipulationCode     : out std_logic_vector(1 downto 0);
        bitManipulationValue    : out std_logic_vector(4 downto 0);

        ALU_opCode              : out std_logic_vector(3 downto 0);
        carryIn                 : out std_logic;
        upperSel                : out std_logic;

        memWriteReq             : out std_logic;
        memReadReq              : out std_logic;

        clearInterrupts         : out std_logic_vector(numInterrupts-1 downto 0);
        dataToALU                 : out std_logic_vector(31 downto 0);
          
        --signals controlling the CU
        programmingMode         : in std_logic;
        IVT_address             : in std_logic_vector(31 downto 0);
        dataFromMem             : in std_logic_vector(31 downto 0);
        dataFromALU             : in std_logic_vector(31 downto 0);
        flagsFromALU            : in std_logic_vector(3 downto 0);
        memOpFinished           : in std_logic;

        --debug signals
        debug : out std_logic_vector(49 downto 0)
);
end controlUnit;

architecture Behavioral of controlUnit is
    type procStateType      is (FETCH1, DECODE_EXECUTE);
    type executeStateType   is (DECODE_EXECUTE1, DECODE_EXECUTE2 ,DECODE_EXECUTE3, DECODE_EXECUTE4, DECODE_EXECUTE5, DECODE_EXECUTE6);

    signal procState        : procStateType    := FETCH1;
    signal procState_nxt    : procStateType;

    signal executeState     : executeStateType := DECODE_EXECUTE1;
    signal executeState_nxt : executeStateType;

    --internal registers
    signal currentlyHandlingInterruptReg : std_logic;

    signal instructionReg                : std_logic_vector(31 downto 0);
    signal instructionReg_nxt            : std_logic_vector(31 downto 0);

    signal CPSR_Reg                      : std_logic_vector(3 downto 0);
    signal CPSR_Reg_nxt                  : std_logic_vector(3 downto 0);

    signal Z_flag : std_logic;
    signal N_flag : std_logic;
    signal V_flag : std_logic;
    signal C_flag : std_logic; 

    --interrupt register
    signal invalidInstructionInterruptReg     : std_logic;
    signal invalidInstructionInterruptReg_nxt : std_logic;

    --operation codes
    --Data Processing
    constant ANDD: std_logic_vector(3 downto 0) := "0000";
    constant EOR: std_logic_vector(3 downto 0) := "0001";
    constant ORR: std_logic_vector(3 downto 0) := "0010";
    constant BIC: std_logic_vector(3 downto 0) := "0011";
    constant NOTT: std_logic_vector(3 downto 0) := "0100";
    constant SUB: std_logic_vector(3 downto 0) := "0101";
    constant BUSS: std_logic_vector(3 downto 0) := "0110";
    constant ADD: std_logic_vector(3 downto 0) := "0111";
    constant ADC: std_logic_vector(3 downto 0) := "1000";
    constant SBC: std_logic_vector(3 downto 0) := "1001";
    constant BSC: std_logic_vector(3 downto 0) := "1010";
    constant MOV: std_logic_vector(3 downto 0) := "1011";
    constant MUL: std_logic_vector(3 downto 0) := "1100";
    constant UMUL: std_logic_vector(3 downto 0) := "1101";

    --Data Movement 
    constant LOAD : std_logic_vector(2 downto 0) := "000";
    constant STORE: std_logic_vector(2 downto 0) := "001";

    --Special Instructions

    --Control Flow


begin
    Z_flag <= CPSR_Reg(3);
    N_flag <= CPSR_Reg(2);
    V_flag <= CPSR_Reg(1);
    C_flag <= CPSR_Reg(0);

    --setting signals
    process(procState, executeState, programmingMode, IVT_address, dataFromMem, dataFromALU, flagsFromALU, memOpFinished)
        variable condition          : std_logic_vector(3 downto 0);
        variable conditionMet       : std_logic;
        type instructionType is (DATA_PROCESSING, DATA_MOVEMENT, SPECIAL, CONTROL_FLOW, INVALID); 
        variable instructionClass : instructionType;

        --variables for the different instruction classes:
        --Data Processing
        variable dataProcessingOpCode : std_logic_vector(3 downto 0);

        --Data Movement
        variable dataMovementOpCode : std_logic_vector(2 downto 0);

        --Special Instructions
        variable specialInstructionOpCode : std_logic_vector(3 downto 0);

        --Control Flow
        variable controlFlowOpCode : std_logic_vector(1 downto 0);

        --variables for different sections within the instruction:
        variable sourceReg      : std_logic_vector(3 downto 0);
        variable destinationReg : std_logic_vector(3 downto 0);
        variable CPSR_Enable    : boolean := False;
        variable immediateValue : std_logic_vector(31 downto 0);

        variable bitManipulationMethod : std_logic_vector(1 downto 0);
        variable bitManipulationImmediateEn : std_logic;
        variable bitManipulationOperand : std_logic_vector(4 downto 0);
        
    begin
        --default assignments
        operand1Sel                         <= (others => '1');
        operand2Sel                         <= (others => '1');
        dataToMemSel                        <= (others => '0');
        dataToRegistersSel                  <= '0';
        bitManipulationValSel               <= (others => '1');
        loadRegistersSel                    <= (others => '0');
        bitManipulationCode                 <= (others => '0');
        bitManipulationValue                <= (others => '0');
        ALU_opCode                          <= (others => '0');
        carryIn                             <= '0';
        upperSel                            <= '0';
        memWriteReq                         <= '0';
        memReadReq                          <= '0';
        clearInterrupts                     <= (others => '0');
        dataToALU                           <= (others => '0');

        instructionReg_nxt                  <= instructionReg;
        procState_nxt                       <= procState;
        executeState_nxt                    <= executeState;
        CPSR_Reg_nxt                        <= CPSR_Reg;
        invalidInstructionInterruptReg_nxt  <= invalidInstructionInterruptReg;

        if procState = FETCH1 then
            operand2Sel         <= "01111";     --selecting PC as operand 2
            dataToRegistersSel  <= '0';         --sending data from ALU to registers in order to write the incremented address back to the PC
            operand1Sel         <= "10000";     --dataToALU as operand 1
            dataToALU           <= x"00000004"; --set dataToALU to 4 to increment PC later
            ALU_opCode          <= "1011";      --tell ALU to move the data
            memReadReq          <= '1';
            if memOpFinished = '1' then                     --wait for data to arrive         
                instructionReg_nxt  <= dataFromMem;          --load current instruction into the instruction register
                ALU_opCode          <= "0111";              --tell ALU to add operand1 (4) to the PC
                loadRegistersSel    <= "1000000000000000";  --load value back into PC
                procState_nxt <= DECODE_EXECUTE;
                executeState_nxt <= DECODE_EXECUTE1;
            end if;

        elsif procState = DECODE_EXECUTE then
            --check for conditions
            condition   := instructionReg(31 downto 28);
            case condition is
                when "0000" => conditionMet := Z_flag;                                  --equal
                when "0001" => conditionMet := not Z_flag;                              --not equal
                when "0010" => conditionMet := C_flag;                                  --unsigned higher or same
                when "0011" => conditionMet := not C_flag;                              --unsigned lower
                when "0100" => conditionMet := N_flag;                                  --negative
                when "0101" => conditionMet := not N_flag;                              --positive or zero
                when "0110" => conditionMet := V_flag;                                  --overflow
                when "0111" => conditionMet := not V_flag;                              --no overflow
                when "1000" => conditionMet := C_flag and (not Z_flag);                 --unsigned higher
                when "1001" => conditionMet := (not C_flag) or Z_flag;                  --unsigned lower or same
                when "1010" => conditionMet := N_flag xnor V_flag;                      --greater or equal
                when "1011" => conditionMet := N_flag xor V_flag;                       --less than
                when "1100" => conditionMet := (not Z_flag) and (N_flag xnor V_flag);   --greater than
                when "1101" => conditionMet := (not Z_flag) or (N_flag xor V_flag);     --less than or equal
                when others => conditionMet := '1';                                     --always
            end case;

            if not conditionMet = '1' then
                procState_nxt <= FETCH1; --skip instruction if condition is not met
            else
                --IF an instruction uses bit manipulation, it will ALWAYS use bit 20-13. Therefore, it can be set in the beginning without any conditions. However, each instruction sets "bitManipulationValSel" individually depending on whether (and if yes how) it  uses bit manipulation. Setting "bitManipulationValSel="11111"" will tell the ALU to not make use of bit manipulation.
                bitManipulationMethod      := instructionReg(20 downto 19);
                bitManipulationImmediateEn := instructionReg(18);
                bitManipulationOperand     := instructionReg(17 downto 13);

                bitManipulationCode <= bitManipulationMethod;
                bitManipulationValue <= bitManipulationOperand;

                --check what kind of instruction class the instruction belongs to
                if instructionReg(27) = '1' then
                    instructionClass := DATA_PROCESSING;
                elsif instructionReg(27 downto 26) = "00" then
                    instructionClass := DATA_MOVEMENT;
                elsif instructionReg(27 downto 25) = "010" then
                    instructionClass := SPECIAL;
                elsif instructionReg(27 downto 25) = "111" then
                    instructionClass := CONTROL_FLOW;
                else
                    instructionClass := INVALID; --needs to be set to avoid latch
                    invalidInstructionInterruptReg_nxt <= '1'; --handle invalid instructions
                    procState_nxt <= FETCH1;
                end if;

                --handle different instruction classes
                if instructionClass = DATA_PROCESSING then
                    dataProcessingOpCode := instructionReg(26 downto 23);
                    ALU_opCode <= dataProcessingOpCode; --tell ALU which operation to perform.
                    dataToRegistersSel <= '0'; --connect the ALU output to the register file (this will be needed for all data processing instructions).
                    
                    --all data processing instructions set the CPSR flags:
                    CPSR_Reg_nxt <= flagsFromALU;


                    if dataProcessingOpCode = MOV then --the MOV instruction is different from the other ones.
                        if instructionReg(4) = '1' then --if this bit is set, the destination register is the CPSR.
                            CPSR_Enable := True;
                        else
                            CPSR_Enable := False;
                            destinationReg := instructionReg(3 downto 0);
                            loadRegistersSel(to_integer(unsigned(destinationReg))) <= '1';
                        end if;
                        if instructionReg(22) = '1' then --checks if the "Immediate Enable Bit" is set.
                            if instructionReg(21) = '1' then --checks if the "Load Higher Bytes Enable Bit" is set.
                                immediateValue := instructionReg(20 downto 5) & x"0000";
                            else
                                immediateValue := x"0000" & instructionReg(20 downto 5);
                            end if;
                            operand2Sel <= "10000"; --tells the ALU to use "dataToALU" as operand 2.
                            dataToALU <= immediateValue;
                        else
                            operand2Sel <= instructionReg(9 downto 5);
                            if instructionReg(9) = '1' then --if this bit is set, the source register is the CPSR.
                                dataToALU <= x"0000000" & CPSR_Reg;
                            end if;
                            if bitManipulationImmediateEn = '1' then 
                                bitManipulationValSel <= "10000"; --uses the "bitManipulationOperand" as immediate value for bit manipulation.
                            else
                                bitManipulationValSel <= '0' & bitManipulationOperand(3 downto 0); --uses the "bitManipulationOperand" as register for bit manipulation
                            end if;
                        
                        end if;

                        --Writing will be down automatically because of the signals that have been set. However, if we want to write back to the CPSR, writing needs to be managed here, because the CPSR register is located within the control unit.
                        if CPSR_Enable = True then 
                            CPSR_Reg_nxt <= dataFromALU(3 downto 0);
                        end if;
                        procState_nxt <= FETCH1;
                
                    else
                        procState_nxt <= FETCH1;
                    end if;


                elsif instructionClass = DATA_MOVEMENT then
                    dataMovementOpCode := instructionReg(25 downto 23);
                    if dataMovementOpCode = STORE then
                        procState_nxt <= FETCH1;

                    elsif dataMovementOpCode = LOAD then
                        procState_nxt <= FETCH1;
                    else
                        invalidInstructionInterruptReg_nxt <= '1'; --handle invalid instructions
                        procState_nxt <= FETCH1; 
                    end if;

                elsif instructionClass = SPECIAL then
                    specialInstructionOpCode := instructionReg(25 downto 22);
                    procState_nxt <= FETCH1;

                elsif instructionClass = CONTROL_FLOW then
                    controlFlowOpCode := instructionReg(25 downto 24);
                    procState_nxt <= FETCH1;
                else 
                    invalidInstructionInterruptReg_nxt <= '1'; --handle invalid instructions
                    procState_nxt <= FETCH1;
                end if;

            end if;
        
        else 
            null;
        end if;
    end process;


    --updating registers
    process(clk, hardwareReset)
    begin
        if hardwareReset = '1' then
            procState           <= FETCH1;
            executeState        <= DECODE_EXECUTE1;
            instructionReg <= (others => '0');
            CPSR_Reg       <= (others => '0');
            
        elsif rising_edge(clk) then
            if enable = '1' then
                if alteredClk = '1' then
                    procState                       <= procState_nxt;
                    executeState                    <= executeState_nxt;
                    instructionReg             <= instructionReg_nxt;
                    CPSR_Reg                   <= CPSR_Reg_nxt;
                    invalidInstructionInterruptReg  <= invalidInstructionInterruptReg_nxt;
                end if;
            end if;
        end if;

    end process;


end Behavioral;
